# -*- coding: utf-8 -*-
"""Kmeans Clustering

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oeXP1agj561EaRnaLzDHD-QzZXUqdU-T
"""



"""IMPORTANDO AS BIBLIOTECAS"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline
# IMPORTAR AS BIBLIOTECAS

"""IMPORTANDO A BASE DE DADOS"""

Base = pd.read_csv('Marvel_Movies_Dataset.csv',index_col=1, sep=';')
# IMPORTA A BASE DE DADOS

Base
# VERIFICAR A BASE DE DADOS

Base.info()
# ANALISAR AS VARIÁVEIS E O NÚMERO DE OBSERVAÇÕES

"""EXPLORAR OS DADOS"""

Base.describe()
# ANALISAR A ESTATISTICA DESCRITIVA

sns.set_style('whitegrid')
sns.lmplot(x='CinemaScore', y='Budget', data=Base, hue='Timeline',
           palette='coolwarm', height=6, aspect=1, fit_reg=False)
# TENTAR VERIFICAR PADRÕES NA BASE DE DADOS

"""CRIANDO O MODELO"""

from sklearn.cluster import KMeans
# IMPORTA O O KMEANS

kmeans = KMeans(n_clusters=2)
# ESCOLHER O NÚMERO DE CLUSTER

kmeans.fit(Base.drop(['Index', 'Director (1)', 'Director (2)', 'Release Date (DD-MM-YYYY)', 'Timeline'], axis=1))
# RODAR MODELO
# SELECIONAR AS VARIÁVEIS
# AQUI EXCLUI STRING


kmeans.cluster_centers_
# DEMONSTRAR OS CENTROIDES

kmeans.labels_
# DEMONSTRAR OS LABELS

"""ENTENDENDO O NOVO CLUSTER"""

Base['Cluster'] = kmeans.labels_
# ADCIONAR O CLUSTER COMO COLUNA NA BASE DE DADOS

Base
# PRINTAR A BASE DE DADOS

#GERAR GRAFICO DE COTOVELO
from sklearn.datasets import make_blobs

# O gráfico de cotovelo é usado para determinar o número ideal de clusters no algoritmo K-Means, baseado na inércia (soma das distâncias quadráticas das amostras ao centro mais próximo).
# Gerar um conjunto de dados de exemplo (opcional)
X, _ = make_blobs(n_samples=300, centers=5, cluster_std=0.7, random_state=42)

# Lista para armazenar a inércia
inertia = []

# Intervalo de possíveis valores de K (número de clusters)
range_k = range(1, 11)

# Calcular K-Means para cada número de clusters e armazenar a inércia
for k in range_k:
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(X)
    inertia.append(kmeans.inertia_)

# Plotar o gráfico de cotovelo
plt.figure(figsize=(8, 6))
plt.plot(range_k, inertia, marker='o', linestyle='--')
plt.title('Gráfico de Cotovelo')
plt.xlabel('Número de Clusters (K)')
plt.ylabel('Inércia')
plt.xticks(range_k)
plt.grid()
plt.show()





#GERAR DENDOGRAMA
from scipy.cluster.hierarchy import dendrogram, linkage
# O dendrograma é uma representação visual da hierarquia dos clusters em análise de agrupamento hierárquico.

# Gerar um conjunto de dados de exemplo (opcional)
X, _ = make_blobs(n_samples=300, centers=4, cluster_std=1.0, random_state=42)

# Computar a matriz de linkage
# 'ward' minimiza a variância dentro dos clusters
linkage_matrix = linkage(X, method='ward')

# Gerar o dendrograma
plt.figure(figsize=(10, 7))
dendrogram(
    linkage_matrix,
    truncate_mode='lastp',  # Mostra apenas os últimos p clusters
    p=30,                  # Número de clusters a serem exibidos
    leaf_rotation=90.,     # Rotação das labels
    leaf_font_size=12.,    # Tamanho da fonte das labels
    show_contracted=True   # Mostra clusters condensados
)
plt.title('Dendrograma para Agrupamento Hierárquico')
plt.xlabel('Índice das amostras ou tamanho dos clusters')
plt.ylabel('Distância')
plt.show()


# EXPLORAR O CRITÉRIO DE SEGMEMNTAÇÃO
sns.set_style('darkgrid')

# Corrigir o parâmetro de tamanho
g = sns.FacetGrid(Base, hue="Cluster", palette='coolwarm', height=6, aspect=2)
g = g.map(plt.hist, 'Worldwide Gross', bins=20, alpha=0.7)

plt.show()


# EXPLORAR O CRITÉRIO DE SEGMEMNTAÇÃO
sns.set_style('whitegrid')

# Corrigir a chamada do lmplot
sns.lmplot(
    x='Domestic Gross', y='Worldwide Gross',
    data=Base, hue='Cluster',
    palette='coolwarm', height=6, aspect=1, fit_reg=False
)

plt.show()